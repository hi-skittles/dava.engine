#ifndef __DAVAENGINE_VEGETATIONRENDERDATA_H__
#define __DAVAENGINE_VEGETATIONRENDERDATA_H__

#include "Base/BaseTypes.h"
#include "Base/BaseObject.h"
#include "Base/FastName.h"
#include "Render/RenderBase.h"
#include "Base/BaseMath.h"

namespace DAVA
{
typedef uint32 VegetationIndex;

struct VegetationVertex
{
    Vector3 coord;
    //Vector3 normal; uncomment, when normals will be used for vertex lit implementation
    Vector2 texCoord0;
    Vector3 texCoord1;
    Vector3 texCoord2;
};

/////////////////////////////////////////////////////////////////////////////////

/**
 \brief Represents a single geometry index buffer
 */
struct VegetationBufferItem
{
    uint32 startIndex;
    uint32 indexCount;
};

/////////////////////////////////////////////////////////////////////////////////

/**
 \brief Encapsulates vegetation layer parameters.
 */
struct VegetationLayerParams
{
    uint32 maxClusterCount;
    float32 instanceRotationVariation; //in angles
    float32 instanceScaleVariation; //0...1. "0" means no variation, "1" means variation from 0 to full scale
};

/////////////////////////////////////////////////////////////////////////////////

/**
 \brief Render data chunk. This chunk is generated by a VegetationGeometry
    subclass in a specific for the implementation way and then is used by the 
    render object to render data in a generic way.
 */
class VegetationRenderData
{
public:
    VegetationRenderData();
    ~VegetationRenderData();

    inline Vector<VegetationVertex>& GetVertices();
    inline Vector<VegetationIndex>& GetIndices();
    inline Vector<Vector<VegetationBufferItem>>& GetIndexBuffers();
    inline NMaterial* GetMaterial();
    inline void SetMaterial(NMaterial* mat);

    void ReleaseRenderData();

    Vector<Vector<uint32>> instanceCount; //layer - lod
    Vector<Vector<uint32>> vertexCountPerInstance; //layer - lod
    Vector<Vector<uint32>> polyCountPerInstance; //layer - lod

private:
    NMaterial* material;
    Vector<VegetationVertex> vertexData;
    Vector<VegetationIndex> indexData;
    Vector<Vector<VegetationBufferItem>> indexRenderDataObject; //resolution - cell
};

/////////////////////////////////////////////////////////////////////////////////

inline Vector<VegetationVertex>& VegetationRenderData::GetVertices()
{
    return vertexData;
}

inline Vector<VegetationIndex>& VegetationRenderData::GetIndices()
{
    return indexData;
}

inline Vector<Vector<VegetationBufferItem>>& VegetationRenderData::GetIndexBuffers()
{
    return indexRenderDataObject;
}

inline NMaterial* VegetationRenderData::GetMaterial()
{
    return material;
}

inline void VegetationRenderData::SetMaterial(NMaterial* mat)
{
    if (mat != material)
    {
        SafeRelease(material);
        material = SafeRetain(mat);
    }
}
};

#endif /* defined(__Framework__VegetationRenderData__) */
